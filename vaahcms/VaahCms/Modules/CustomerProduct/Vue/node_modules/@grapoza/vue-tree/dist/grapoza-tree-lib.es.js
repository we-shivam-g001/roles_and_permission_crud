import { unref as i, ref as j, watch as J, computed as T, inject as ot, watchEffect as nt, toRef as Z, resolveComponent as at, openBlock as q, createElementBlock as M, normalizeClass as P, createElementVNode as L, renderSlot as E, withDirectives as De, vModelCheckbox as it, createTextVNode as Me, toDisplayString as we, vModelRadio as rt, createCommentVNode as Q, Fragment as Be, renderList as He, createBlock as Je, withCtx as z, vShow as st, readonly as ut, onMounted as dt, nextTick as ct, provide as ft } from "vue";
const A = Object.freeze({
  None: null,
  Single: "single",
  Multiple: "multiple",
  SelectionFollowsFocus: "selectionFollowsFocus"
});
function Ge() {
  function t() {
    const a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let n = "grt-";
    do
      n += a.charAt(Math.floor(Math.random() * a.length));
    while (n.length < 8 || document.getElementById(n));
    return n;
  }
  function o(a, n) {
    const b = a.treeNodeSpec.idProperty, s = a[b], h = a[a.treeNodeSpec.childrenProperty];
    if (document.getElementById(`${n}-${s}`)) {
      let e = 1;
      for (; document.getElementById(`${n}-${s}-${e}`); )
        e++;
      a[b] = `${s}-${e}`;
    }
    h.forEach((e) => o(e, n));
  }
  return { generateUniqueId: t, resolveNodeIdConflicts: o };
}
function Ie() {
  function t(o) {
    var a;
    return i(o)[(a = i(o).treeNodeSpec.childrenProperty) != null ? a : "children"];
  }
  return {
    getChildren: t
  };
}
function ve() {
  const {
    getChildren: t
  } = Ie();
  function o(n) {
    return a(t(n));
  }
  function a(n) {
    return i(n).filter((b) => {
      var s, h, e, l, C, g;
      return ((e = (h = (s = b.treeNodeSpec) == null ? void 0 : s._) == null ? void 0 : h.state) == null ? void 0 : e.matchesFilter) || ((g = (C = (l = b.treeNodeSpec) == null ? void 0 : l._) == null ? void 0 : C.state) == null ? void 0 : g.subnodeMatchesFilter);
    });
  }
  return {
    getFilteredChildren: o,
    getFilteredNodes: a
  };
}
function Pe(t) {
  const {
    getFilteredChildren: o,
    getFilteredNodes: a
  } = ve();
  function n(h) {
    s(h, !1);
  }
  function b(h) {
    s(h, !0);
  }
  function s(h, e) {
    const l = a(t);
    if (l.length === 0)
      return;
    let C = l.slice(), g = !0;
    for (; C.length > 0 && g !== !1; ) {
      const p = C.shift(), c = o(p);
      C = e ? c.concat(C) : C.concat(c), g = h(p);
    }
  }
  return {
    breadthFirstTraverse: n,
    depthFirstTraverse: b
  };
}
function Ue() {
  function t(a) {
    return i(a).treeNodeSpec.expandable === !0;
  }
  function o(a) {
    return i(a).treeNodeSpec.state.expanded === !0;
  }
  return {
    isExpandable: t,
    isExpanded: o
  };
}
function B() {
  const { isExpanded: t } = Ue(), {
    getFilteredChildren: o,
    getFilteredNodes: a
  } = ve();
  function n(g, p = !1) {
    i(g).treeNodeSpec._.keepCurrentDomFocus = p, i(g).treeNodeSpec.focusable = !0;
  }
  function b(g) {
    i(g).treeNodeSpec.focusable = !1;
  }
  function s(g) {
    return i(g).treeNodeSpec.focusable === !0;
  }
  function h(g, p = !1) {
    const c = a(g);
    c.length > 0 && n(c[0], p);
  }
  function e(g, p = !1) {
    const c = a(g);
    let N = c[c.length - 1], S = o(N);
    for (; S.length > 0 && t(N); )
      N = S[S.length - 1], S = o(N);
    n(N, p);
  }
  function l(g, p, c, N = !1) {
    const S = a(g);
    let f = S.findIndex((m) => m[m.treeNodeSpec.idProperty] === p[p.treeNodeSpec.idProperty]), u = o(p);
    if (!c && u.length > 0 && t(p))
      n(u[0], N);
    else if (f < S.length - 1)
      n(S[f + 1], N);
    else
      return !1;
    return !0;
  }
  function C(g, p, c = !1) {
    const N = a(g);
    let S = N.findIndex((f) => f[f.treeNodeSpec.idProperty] === p[p.treeNodeSpec.idProperty]);
    if (S !== 0) {
      let f = N[S - 1], u = o(f);
      for (; u.length > 0 && t(f); )
        f = u[u.length - 1], u = o(f);
      return n(f, c), !0;
    }
    return !1;
  }
  return {
    focus: n,
    focusFirst: h,
    focusLast: e,
    focusNext: l,
    focusPrevious: C,
    isFocused: s,
    unfocus: b
  };
}
function pt() {
  const { unfocus: t } = B(), o = j(null);
  function a(n) {
    o.value !== n && (o.value && t(o), o.value = n);
  }
  return {
    focusableNodeModel: o,
    handleFocusableChange: a
  };
}
function ge() {
  function t(s) {
    i(s).treeNodeSpec.state.selected = !0;
  }
  function o(s) {
    i(s).treeNodeSpec.state.selected = !1;
  }
  function a(s, h) {
    i(s).treeNodeSpec.state.selected = h;
  }
  function n(s) {
    return i(s).treeNodeSpec.selectable === !0;
  }
  function b(s) {
    return i(s).treeNodeSpec.state.selected === !0;
  }
  return {
    deselect: o,
    isSelectable: n,
    isSelected: b,
    setSelected: a,
    select: t
  };
}
function vt(t) {
  const { getFilteredNodes: o } = ve(), { focusFirst: a } = B();
  let n = o(t).length === 0;
  return J(() => o(t), () => {
    o(t).length > 0 ? (n && a(t, !0), n = !1) : n = !0;
  }), {};
}
const r = Object.freeze({
  RootNodesLoad: "treeRootNodesLoad",
  Click: "treeNodeClick",
  DoubleClick: "treeNodeDblclick",
  CheckboxChange: "treeNodeCheckboxChange",
  ChildCheckboxChange: "treeNodeChildCheckboxChange",
  RadioChange: "treeNodeRadioChange",
  ExpandedChange: "treeNodeExpandedChange",
  ChildrenLoad: "treeNodeChildrenLoad",
  SelectedChange: "treeNodeSelectedChange",
  FocusableChange: "treeNodeAriaFocusableChange",
  RequestFirstFocus: "treeNodeAriaRequestFirstFocus",
  RequestLastFocus: "treeNodeAriaRequestLastFocus",
  RequestParentFocus: "treeNodeAriaRequestParentFocus",
  RequestPreviousFocus: "treeNodeAriaRequestPreviousFocus",
  RequestNextFocus: "treeNodeAriaRequestNextFocus",
  Add: "treeNodeAdd",
  Delete: "treeNodeDelete",
  DragMove: "treeNodeDragMove",
  Drop: "treeNodeDrop"
});
function gt(t, o, a, n) {
  const { depthFirstTraverse: b } = Pe(t), { deselect: s, isSelectable: h, isSelected: e, select: l } = ge();
  J(o, g), J(a, (f) => {
    i(o) === A.SelectionFollowsFocus && S(f);
  });
  const C = T(() => o.value === A.None ? null : o.value === A.Multiple);
  function g() {
    i(o) === A.Single ? p() : i(o) === A.SelectionFollowsFocus && c();
  }
  function p() {
    let f = !1;
    b((u) => {
      u.treeNodeSpec.state && e(u) && (f ? s(u) : f = !0);
    });
  }
  function c() {
    b((f) => {
      let u = f.treeNodeSpec.idProperty, m = a.value.treeNodeSpec.idProperty;
      f[u] === a.value[m] ? h(f) && l(f) : e(f) && s(f);
    });
  }
  function N(f) {
    i(o) === A.Single && e(f) && S(f), n(r.SelectedChange, f);
  }
  function S(f) {
    const u = f[f.treeNodeSpec.idProperty];
    b((m) => e(m) && m[m.treeNodeSpec.idProperty] !== u ? (s(m), !1) : !0);
  }
  return {
    ariaMultiselectable: C,
    enforceSelectionMode: g,
    handleNodeSelectedChange: N
  };
}
const Ze = Object.freeze({
  None: "none",
  Copy: "copy",
  Move: "move",
  Link: "link"
}), ne = Object.freeze({
  None: "none",
  All: "all",
  Copy: "copy",
  Move: "move",
  Link: "link",
  CopyMove: "copyMove",
  CopyLink: "copyLink",
  LinkMove: "linkMove"
}), W = Object.freeze({
  Before: 0,
  After: 1,
  Child: 2
});
function Qe() {
  function t(a) {
    return a !== null && typeof a == "object" && !Array.isArray(a);
  }
  function o(a) {
    let n = JSON.parse(JSON.stringify(a));
    if (t(n))
      for (const b of Object.keys(a)) {
        let s = a[b];
        typeof s == "function" ? n[b] = s : t(s) && (n[b] = o(s));
      }
    return n;
  }
  return { isProbablyObject: t, cheapCopyObject: o };
}
const { resolveNodeIdConflicts: je } = Ge(), { cheapCopyObject: Nt } = Qe(), { unfocus: ht } = B();
function Ct(t, o, a, n) {
  function b(h) {
    const e = t.value.indexOf(h);
    e > -1 && t.value.splice(e, 1);
  }
  function s(h) {
    let e = h.droppedModel;
    if (h.isSameTree)
      if (h.dropEffect === Ze.Move)
        e = n(e[e.treeNodeSpec.idProperty]), e.treeNodeSpec._.dragMoved = !0;
      else {
        let l = a(e[e.treeNodeSpec.idProperty]);
        e = Nt(l), je(e, o.value), ht(e);
      }
    else
      je(e, o.value);
    if (e) {
      let l = h.siblingNodeSet || t.value, C = l.indexOf(h.targetModel);
      switch (h.targetZone) {
        case W.Before:
          l.splice(C, 0, e);
          break;
        case W.After:
          l.splice(C + 1, 0, e);
          break;
        default:
          l.push(e);
          break;
      }
      e.treeNodeSpec._.dragging = !1;
    }
  }
  return {
    dragMoveNode: b,
    drop: s
  };
}
const ae = Object.freeze({
  Checkbox: "checkbox",
  RadioButton: "radio"
});
function yt(t, o, a) {
  const { depthFirstTraverse: n } = Pe(t), { isSelectable: b, isSelected: s } = ge();
  function h(c, N = 0) {
    let S = [];
    return typeof c == "function" && n((f) => {
      if (c(f))
        return S.push(f), N < 1 || S.length < N;
    }), S;
  }
  function e() {
    return h((c) => c.treeNodeSpec.input && c.treeNodeSpec.input.type === ae.Checkbox && c.treeNodeSpec.state.input.value);
  }
  function l() {
    return h((c) => c.treeNodeSpec.input && c.treeNodeSpec.input.type === ae.RadioButton && o.value[c.treeNodeSpec.input.name] === c.treeNodeSpec.input.value);
  }
  function C(c) {
    let N = null;
    return typeof c == "string" && (N = t.value.find((S) => S[S.treeNodeSpec.idProperty] === c), N || n((S) => {
      if (N = S[S.treeNodeSpec.childrenProperty].find((u) => u[u.treeNodeSpec.idProperty] === c), N)
        return !1;
    })), N;
  }
  function g() {
    return a.value === A.None ? [] : h((c) => b(c) && s(c));
  }
  function p(c) {
    let N = null;
    if (typeof c == "string") {
      let S = t.value.findIndex((f) => f[f.treeNodeSpec.idProperty] === c);
      S > -1 ? N = t.value.splice(S, 1)[0] : n((f) => {
        let u = f[f.treeNodeSpec.childrenProperty];
        if (S = u.findIndex((m) => m[m.treeNodeSpec.idProperty] === c), S > -1)
          return N = u.splice(S, 1)[0], !1;
      });
    }
    return N;
  }
  return {
    findById: C,
    getCheckedCheckboxes: e,
    getCheckedRadioButtons: l,
    getMatching: h,
    getSelected: g,
    removeById: p
  };
}
const { isProbablyObject: Ke } = Qe(), bt = [ne.Copy, ne.Move, ne.CopyMove, ne.None];
function St(t, o, a) {
  function n() {
    t.value.treeNodeSpec || (t.value.treeNodeSpec = {});
    const e = t.value.treeNodeSpec;
    b(i(o), e), typeof e.childrenProperty != "string" && (e.childrenProperty = "children"), typeof e.idProperty != "string" && (e.idProperty = "id"), typeof e.labelProperty != "string" && (e.labelProperty = "label"), Array.isArray(t.value[e.childrenProperty]) || (t.value[e.childrenProperty] = []), typeof e.expandable != "boolean" && (e.expandable = !0), typeof e.selectable != "boolean" && (e.selectable = !1), typeof e.deletable != "boolean" && (e.deletable = !1), typeof e.draggable != "boolean" && (e.draggable = !1), typeof e.allowDrop != "boolean" && (e.allowDrop = !1), (typeof e.dataTransferEffectAllowed != "string" || !bt.includes(e.dataTransferEffectAllowed)) && (e.dataTransferEffectAllowed = ne.CopyMove), typeof e.focusable != "boolean" && (e.focusable = !1), typeof e.addChildCallback != "function" && (e.addChildCallback = null), typeof e.deleteNodeCallback != "function" && (e.deleteNodeCallback = null), (typeof e.title != "string" || e.title.trim().length === 0) && (e.title = null), (typeof e.expanderTitle != "string" || e.expanderTitle.trim().length === 0) && (e.expanderTitle = null), (typeof e.addChildTitle != "string" || e.addChildTitle.trim().length === 0) && (e.addChildTitle = null), (typeof e.deleteTitle != "string" || e.deleteTitle.trim().length === 0) && (e.deleteTitle = null), (e.customizations == null || typeof e.customizations != "object") && (e.customizations = {}), typeof e.loadChildrenAsync != "function" && (e.loadChildrenAsync = null), e._ = {}, e._.dragging = !1, s(e), h(e), t.value.treeNodeSpec = e;
  }
  function b(e, l) {
    if (Ke(e)) {
      const C = JSON.parse(JSON.stringify(e));
      Object.assign(C, l);
      for (const g of Object.keys(e)) {
        const p = typeof e[g] == "function" ? e[g] : C[g];
        Ke(p) ? (l[g] = l[g] || {}, b(p, l[g])) : (typeof p == "function" && l[g], l[g] = p);
      }
    }
  }
  function s(e) {
    let l = e.input;
    l === null || typeof l != "object" || !Object.values(ae).includes(l.type) ? e.input = null : ((typeof l.name != "string" || l.name.trim().length === 0) && (l.name = null), l.type === ae.RadioButton && ((typeof l.name != "string" || l.name.trim().length === 0) && (l.name = "unspecifiedRadioName"), (typeof l.value != "string" || l.value.trim().length === 0) && (l.value = t.value[e.labelProperty].replace(/[\s&<>"'\/]/g, "")), a.value.hasOwnProperty(l.name) || (a.value[l.name] = ""), l.isInitialRadioGroupValue === !0 && (a.value[l.name] = l.value)));
  }
  function h(e) {
    (e.state === null || typeof e.state != "object") && (e.state = {}), (e._.state === null || typeof e._.state != "object") && (e._.state = {});
    let l = e.state, C = e._.state;
    C.areChildrenLoaded = typeof e.loadChildrenAsync != "function", C.areChildrenLoading = !1, (typeof l.expanded != "boolean" || !C.areChildrenLoaded) && (l.expanded = !1), typeof l.selected != "boolean" && (l.selected = !1), e.input && ((l.input === null || typeof l.input != "object") && (l.input = {}), (l.input.disabled === null || typeof l.input.disabled != "boolean") && (l.input.disabled = !1), e.input.type === ae.Checkbox && typeof l.input.value != "boolean" && (l.input.value = !1));
  }
  return {
    normalizeNodeData: n
  };
}
function Ae(t, o) {
  const {
    getChildren: a
  } = Ie(), n = T(() => typeof t.value.treeNodeSpec.loadChildrenAsync != "function" || t.value.treeNodeSpec._.state.areChildrenLoaded), b = T(() => t.value.treeNodeSpec._.state.areChildrenLoading), s = T(() => a(t)), h = T(() => s.value && s.value.length > 0), e = T(() => h.value || !n.value);
  async function l() {
    const p = t.value.treeNodeSpec;
    if (!p._.state.areChildrenLoaded && !p._.state.areChildrenLoading) {
      p._.state.areChildrenLoading = !0;
      var c = await p.loadChildrenAsync(t.value);
      c && (p._.state.areChildrenLoaded = !0, s.value.splice(0, s.value.length, ...c), o(r.ChildrenLoad, t.value)), p._.state.areChildrenLoading = !1;
    }
  }
  async function C() {
    if (t.value.treeNodeSpec.addChildCallback) {
      var p = await t.value.treeNodeSpec.addChildCallback(t.value);
      p && (s.value.push(p), o(r.Add, p, t.value));
    }
  }
  function g(p) {
    let c = s.value.indexOf(p);
    c > -1 && (s.value.splice(c, 1), o(r.Delete, p));
  }
  return {
    addChild: C,
    areChildrenLoaded: n,
    areChildrenLoading: b,
    children: s,
    deleteChild: g,
    hasChildren: h,
    loadChildren: l,
    mayHaveChildren: e
  };
}
const oe = Object.freeze({
  Json: "application/json",
  PlainText: "text/plain",
  TreeViewNode: "application/x-grapoza-treeviewnode"
});
function mt() {
  function t(o, a) {
    return (o.closest ? o : o.parentElement).closest(a);
  }
  return {
    closest: t
  };
}
const { closest: xt } = mt();
function kt(t, o, a, n) {
  const { unfocus: b } = B(), s = t.value.treeNodeSpec;
  function h(u) {
    const m = o.value.indexOf(u);
    m > -1 && o.value.splice(m, 1);
  }
  function e(u, m) {
    u.siblingNodeSet = u.siblingNodeSet || o.value, n(r.Drop, u, m);
  }
  function l(u) {
    u.stopPropagation();
    let m = JSON.parse(JSON.stringify(t.value));
    b(m), m = JSON.stringify(m), s._.dragging = !0, u.dataTransfer.effectAllowed = s.dataTransferEffectAllowed, u.dataTransfer.setData(oe.TreeViewNode, `{"treeId":"${a.value}","data":${m}}`), u.dataTransfer.setData(oe.Json, m), u.dataTransfer.setData(oe.PlainText, m);
  }
  function C(u) {
    S(u) && (f(u, !0), u.preventDefault());
  }
  function g(u) {
    S(u) && (f(u, !0), u.preventDefault());
  }
  function p(u) {
    S(u) && f(u, !1);
  }
  function c(u) {
    const m = JSON.parse(u.dataTransfer.getData(oe.TreeViewNode)), y = u.target.classList.contains("grtvn-self-prev-target") ? W.Before : u.target.classList.contains("grtvn-self-next-target") ? W.After : W.Child, $ = {
      isSameTree: m.treeId === a.value,
      droppedModel: m.data,
      targetModel: t.value,
      siblingNodeSet: y === W.Child ? o.value : null,
      dropEffect: u.dataTransfer.dropEffect,
      targetZone: y
    };
    n(r.Drop, $, u), f(u, !1), u.preventDefault();
  }
  function N(u) {
    u.dataTransfer.dropEffect === Ze.Move ? s._.dragMoved ? delete s._.dragMoved : n(r.DragMove, t.value, u) : (f(u, !1), s._.dragging = !1);
  }
  function S(u) {
    return s.allowDrop && u.dataTransfer.types.includes(oe.TreeViewNode) && !xt(u.target, ".grtvn-dragging");
  }
  function f(u, m) {
    const y = u.target.classList && u.target.classList.contains("grtvn-self-prev-target"), $ = u.target.classList && u.target.classList.contains("grtvn-self-next-target");
    s._.isDropTarget = m, y ? (s._.isPrevDropTarget = m, s._.isChildDropTarget = !1) : $ ? (s._.isNextDropTarget = m, s._.isChildDropTarget = !1) : s._.isChildDropTarget = m;
  }
  return {
    dragMoveChild: h,
    drop: e,
    onDragstart: l,
    onDragenter: C,
    onDragover: g,
    onDragleave: p,
    onDrop: c,
    onDragend: N
  };
}
function Ft(t, o, a, n) {
  const { focus: b, focusFirst: s, focusLast: h, focusNext: e, focusPrevious: l, isFocused: C, unfocus: g } = B(), { getChildren: p } = Ie(), c = T(() => p(t));
  J(() => t.value.treeNodeSpec.focusable, function(V) {
    V === !0 && (n.value && !t.value.treeNodeSpec._.keepCurrentDomFocus && o.value.focus(), delete t.value.treeNodeSpec._.keepCurrentDomFocus, a(r.FocusableChange, t.value));
  });
  function N(V = !1) {
    b(t, V);
  }
  function S() {
    g(t);
  }
  function f() {
    return C(t);
  }
  function u(V = !1) {
    s(c.value, V);
  }
  function m(V = !1) {
    h(c.value, V);
  }
  function y(V, O, X = !1) {
    e(c.value, V, O, X) || a(r.RequestNextFocus, i(t), !0);
  }
  function $(V, O = !1) {
    l(c.value, V, O) || N(O);
  }
  return {
    focusNode: N,
    unfocusNode: S,
    isFocusedNode: f,
    focusFirstChild: u,
    focusLastChild: m,
    focusNextNode: y,
    focusPreviousNode: $
  };
}
function Tt(t, o, a) {
  const {
    deselect: n,
    isSelectable: b,
    isSelected: s,
    setSelected: h,
    select: e
  } = ge();
  J(() => t.value.treeNodeSpec.state.selected, () => {
    a(r.SelectedChange, t.value);
  }), J(() => t.value.treeNodeSpec.focusable, function(f) {
    c() && o.value === A.SelectionFollowsFocus && g(f);
  });
  function l() {
    e(t);
  }
  function C() {
    n(t);
  }
  function g(f) {
    h(t, f);
  }
  function p() {
    b(t) && [A.Single, A.Multiple].includes(o.value) && h(t, !N());
  }
  function c() {
    return b(t);
  }
  function N() {
    return s(t);
  }
  return {
    ariaSelected: T(() => o.value === A.None || !c() ? null : o.value !== A.Multiple ? N() ? !0 : null : N()),
    deselectNode: C,
    isNodeSelectable: c,
    isNodeSelected: N,
    setNodeSelected: g,
    selectNode: l,
    toggleNodeSelected: p
  };
}
function We(t, o) {
  const a = ot("filterMethod"), {
    isFocused: n,
    unfocus: b
  } = B(), {
    areChildrenLoaded: s
  } = Ae(t), {
    getFilteredChildren: h
  } = ve(), e = T(() => h(t)), l = T(() => typeof i(a) == "function"), C = T(() => t.value.treeNodeSpec._.state.matchesFilter || t.value.treeNodeSpec._.state.subnodeMatchesFilter || !1), g = T(() => e.value && e.value.length > 0), p = T(() => g.value || !s.value);
  return nt(() => {
    const c = t.value.treeNodeSpec;
    c._.state.matchesFilter = !l.value || i(a)(t.value), c._.state.subnodeMatchesFilter = e.value.length > 0, !C.value && n(t) && (b(t), o(r.RequestFirstFocus, !0));
  }), {
    filteredChildren: e,
    filterIncludesNode: C,
    isFilteringEnabled: l,
    mayHaveFilteredChildren: p
  };
}
function Dt(t, o) {
  const {
    isExpandable: a,
    isExpanded: n
  } = Ue(), {
    loadChildren: b
  } = Ae(t, o), {
    mayHaveFilteredChildren: s
  } = We(t, o), h = T(() => e.value ? C() : null), e = T(() => l() && s.value);
  J(() => t.value.treeNodeSpec.state.expanded, async function() {
    o(r.ExpandedChange, t.value), C() && await b();
  });
  function l() {
    return a(t);
  }
  function C() {
    return n(t);
  }
  function g() {
    return e.value && C() ? (t.value.treeNodeSpec.state.expanded = !1, !0) : !1;
  }
  function p() {
    return e.value && !C() ? (t.value.treeNodeSpec.state.expanded = !0, !0) : !1;
  }
  function c() {
    return C() ? g() : p();
  }
  return {
    ariaExpanded: h,
    canExpand: e,
    collapseNode: g,
    expandNode: p,
    isNodeExpandable: l,
    isNodeExpanded: C,
    toggleNodeExpanded: c
  };
}
const wt = ["id", "tabindex", "aria-expanded", "aria-selected"], It = ["draggable", "dragging"], Pt = ["id", "title"], At = ["for", "title"], Rt = ["id", "disabled"], Vt = ["for", "title"], Lt = ["id", "name", "value", "disabled"], Et = ["title"], qt = ["id", "title"], $t = ["id", "title"], Ot = ["aria-hidden"], ze = "input, .grtvn-self-expander, .grtvn-self-expander *, .grtvn-self-action, .grtvn-self-action *", Mt = {
  __name: "TreeViewNode",
  props: {
    ariaKeyMap: {
      type: Object,
      required: !0
    },
    depth: {
      type: Number,
      required: !0
    },
    initialModel: {
      type: Object,
      required: !0
    },
    initialRadioGroupValues: {
      type: Object,
      required: !0
    },
    isMounted: {
      type: Boolean,
      required: !0
    },
    modelDefaults: {
      type: Object,
      required: !0
    },
    selectionMode: {
      type: String,
      required: !1,
      default: A.None,
      validator: function(t) {
        return Object.values(A).includes(t);
      }
    },
    treeId: {
      type: String,
      required: !0
    }
  },
  emits: [
    r.Add,
    r.Click,
    r.CheckboxChange,
    r.ChildCheckboxChange,
    r.ChildrenLoad,
    r.Delete,
    r.DoubleClick,
    r.DragMove,
    r.Drop,
    r.ExpandedChange,
    r.FocusableChange,
    r.RadioChange,
    r.RequestFirstFocus,
    r.RequestLastFocus,
    r.RequestNextFocus,
    r.RequestParentFocus,
    r.RequestPreviousFocus,
    r.SelectedChange
  ],
  setup(t, { emit: o }) {
    const a = t, n = j(a.initialModel), b = j(a.initialRadioGroupValues), s = j(null), h = T(() => `${m.value}-add-child`), e = T(() => me() ? 0 : -1), l = T(() => {
      var d, v;
      return (v = (d = y.value.customizations) == null ? void 0 : d.classes) != null ? v : {};
    }), C = T(() => `${m.value}-delete`), g = T(() => `${m.value}-exp`), p = T(() => n.value[c.value]), c = T(() => {
      var d;
      return (d = y.value.idProperty) != null ? d : "id";
    }), N = T(() => `${m.value}-input`), S = T(() => a.selectionMode !== A.None && xe() && ke()), f = T(() => n.value[u.value]), u = T(() => {
      var d;
      return (d = y.value.labelProperty) != null ? d : "label";
    }), m = T(() => `${a.treeId}-${p.value}`), y = T(() => n.value.treeNodeSpec), $ = T(() => a.treeId), { normalizeNodeData: V } = St(n, a.modelDefaults, b);
    V();
    const {
      addChild: O,
      areChildrenLoaded: X,
      areChildrenLoading: ie,
      children: Y,
      deleteChild: Ne,
      hasChildren: he
    } = Ae(n, o), {
      filteredChildren: G,
      filterIncludesNode: Ce,
      mayHaveFilteredChildren: ye
    } = We(n, o), {
      focus: be,
      isFocused: Se
    } = B(), {
      focusNode: re,
      focusNextNode: se,
      focusPreviousNode: ue,
      isFocusedNode: me
    } = Ft(n, s, o, Z(a, "isMounted")), {
      ariaSelected: _,
      isNodeSelectable: xe,
      isNodeSelected: ke,
      toggleNodeSelected: de
    } = Tt(n, Z(a, "selectionMode"), o), {
      ariaExpanded: Fe,
      canExpand: k,
      collapseNode: x,
      expandNode: ee,
      isNodeExpanded: ce,
      toggleNodeExpanded: te
    } = Dt(n, o), {
      dragMoveChild: F,
      drop: I,
      onDragstart: K,
      onDragenter: U,
      onDragover: fe,
      onDragleave: Re,
      onDrop: Ve,
      onDragend: Le
    } = kt(n, Y, $, o);
    function Ee(d) {
      o(r.CheckboxChange, n.value, d);
    }
    function qe(d) {
      o(r.RadioChange, n.value, d);
    }
    function Xe(d) {
      d.target.matches(ze) || (o(r.Click, n.value, d), de()), re();
    }
    function Ye(d) {
      d.target.matches(ze) || o(r.DoubleClick, n.value, d);
    }
    async function $e(d) {
      var v, H, D;
      y.value.deletable && ((D = await ((H = (v = y.value).deleteNodeCallback) == null ? void 0 : H.call(v, n.value))) != null ? D : !0) && o(r.Delete, n.value);
    }
    function _e(d) {
      let v = !0;
      if (!(d.altKey || d.ctrlKey || d.metaKey || d.shift)) {
        if (a.ariaKeyMap.activateItem.includes(d.keyCode)) {
          if (y.value.input && !y.value.state.input.disabled) {
            let H = s.value.querySelector(".grtvn-self"), D = H.querySelector(".grtvn-self-input") || H.querySelector("input");
            if (D) {
              let pe = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !0 });
              D.dispatchEvent(pe);
            }
          }
        } else
          a.ariaKeyMap.selectItem.includes(d.keyCode) ? de() : a.ariaKeyMap.expandFocusedItem.includes(d.keyCode) ? ye.value && !ie.value && !ee() && ce() && be(G.value[0]) : a.ariaKeyMap.collapseFocusedItem.includes(d.keyCode) ? x() || o(r.RequestParentFocus) : a.ariaKeyMap.focusFirstItem.includes(d.keyCode) ? o(r.RequestFirstFocus) : a.ariaKeyMap.focusLastItem.includes(d.keyCode) ? o(r.RequestLastFocus) : a.ariaKeyMap.focusPreviousItem.includes(d.keyCode) ? o(r.RequestPreviousFocus, n.value) : a.ariaKeyMap.focusNextItem.includes(d.keyCode) ? o(r.RequestNextFocus, n.value, !1) : a.ariaKeyMap.insertItem.includes(d.keyCode) ? O() : a.ariaKeyMap.deleteItem.includes(d.keyCode) ? $e() : v = !1;
        v && (d.stopPropagation(), d.preventDefault());
      }
    }
    function et(d) {
      G.value.indexOf(d) > -1 && (Se(d) && (G.value.length > 1 && G.value.indexOf(d) === 0 ? se(d) : ue(d)), Ne(d));
    }
    function tt(d, v) {
      o(r.CheckboxChange, d, v), Y.value.includes(d) && o(r.ChildCheckboxChange, n.value, d, v);
    }
    return (!p.value || typeof p.value != "number" && typeof p.value != "string") && console.error(`initialModel id is required and must be a number or string. Expected prop ${c.value} to exist on the model.`), (!f.value || typeof f.value != "string") && console.error(`initialModel label is required and must be a string. Expected prop ${u.value} to exist on the model.`), (d, v) => {
      const H = at("TreeViewNode", !0);
      return q(), M("li", {
        id: m.value,
        ref_key: "nodeElement",
        ref: s,
        class: P(["grtvn", [
          l.value.treeViewNode,
          y.value._.dragging ? "grtvn-dragging" : "",
          i(Ce) ? "" : "grtvn-hidden"
        ]]),
        role: "treeitem",
        tabindex: e.value,
        "aria-expanded": i(Fe),
        "aria-selected": i(_),
        onKeydown: _e
      }, [
        L("div", {
          class: P(["grtvn-self", [
            l.value.treeViewNodeSelf,
            S.value ? "grtvn-self-selected" : "",
            S.value ? l.value.treeViewNodeSelfSelected : "",
            y.value._.isDropTarget ? "grtvn-self-drop-target" : "",
            y.value._.isChildDropTarget ? "grtvn-self-child-drop-target" : ""
          ]]),
          draggable: y.value.draggable,
          dragging: y.value._.dragging,
          onClick: Xe,
          onDblclick: Ye,
          onDragend: v[4] || (v[4] = (...D) => i(Le) && i(Le)(...D)),
          onDragenter: v[5] || (v[5] = (...D) => i(U) && i(U)(...D)),
          onDragleave: v[6] || (v[6] = (...D) => i(Re) && i(Re)(...D)),
          onDragover: v[7] || (v[7] = (...D) => i(fe) && i(fe)(...D)),
          onDragstart: v[8] || (v[8] = (...D) => i(K) && i(K)(...D)),
          onDrop: v[9] || (v[9] = (...D) => i(Ve) && i(Ve)(...D))
        }, [
          L("div", {
            class: P(["grtvn-self-sibling-drop-target grtvn-self-prev-target", [y.value._.isPrevDropTarget ? "grtvn-self-sibling-drop-target-hover" : ""]])
          }, null, 2),
          i(k) ? (q(), M("button", {
            key: 0,
            id: g.value,
            type: "button",
            "aria-hidden": "true",
            tabindex: "-1",
            title: y.value.expanderTitle,
            class: P(["grtvn-self-expander", [
              l.value.treeViewNodeSelfExpander,
              y.value.state.expanded ? "grtvn-self-expanded" : "",
              y.value.state.expanded ? l.value.treeViewNodeSelfExpanded : ""
            ]]),
            onClick: v[0] || (v[0] = (...D) => i(te) && i(te)(...D))
          }, [
            L("i", {
              class: P(["grtvn-self-expanded-indicator", l.value.treeViewNodeSelfExpandedIndicator])
            }, null, 2)
          ], 10, Pt)) : (q(), M("span", {
            key: 1,
            class: P(["grtvn-self-spacer", l.value.treeViewNodeSelfSpacer])
          }, null, 2)),
          y.value.input && y.value.input.type === "checkbox" ? E(d.$slots, "checkbox", {
            key: 2,
            model: n.value,
            customClasses: l.value,
            inputId: N.value,
            checkboxChangeHandler: Ee
          }, () => [
            L("label", {
              for: N.value,
              title: y.value.title,
              class: P(["grtvn-self-label", l.value.treeViewNodeSelfLabel])
            }, [
              De(L("input", {
                id: N.value,
                tabindex: "-1",
                class: P(["grtvn-self-input grtvn-self-checkbox", [l.value.treeViewNodeSelfInput, l.value.treeViewNodeSelfCheckbox]]),
                type: "checkbox",
                disabled: y.value.state.input.disabled,
                "onUpdate:modelValue": v[1] || (v[1] = (D) => y.value.state.input.value = D),
                onChange: Ee
              }, null, 42, Rt), [
                [it, y.value.state.input.value]
              ]),
              Me(" " + we(f.value), 1)
            ], 10, At)
          ]) : y.value.input && y.value.input.type === "radio" ? E(d.$slots, "radio", {
            key: 3,
            model: n.value,
            customClasses: l.value,
            inputId: N.value,
            radioGroupValues: b.value,
            radioChangeHandler: qe
          }, () => [
            L("label", {
              for: N.value,
              title: y.value.title,
              class: P(["grtvn-self-label", l.value.treeViewNodeSelfLabel])
            }, [
              De(L("input", {
                id: N.value,
                tabindex: "-1",
                class: P(["grtvn-self-input grtvn-self-radio", [l.value.treeViewNodeSelfInput, l.value.treeViewNodeSelfRadio]]),
                type: "radio",
                name: y.value.input.name,
                value: y.value.input.value,
                disabled: y.value.state.input.disabled,
                "onUpdate:modelValue": v[2] || (v[2] = (D) => b.value[y.value.input.name] = D),
                onChange: qe
              }, null, 42, Lt), [
                [rt, b.value[y.value.input.name]]
              ]),
              Me(" " + we(f.value), 1)
            ], 10, Vt)
          ]) : E(d.$slots, "text", {
            key: 4,
            model: n.value,
            customClasses: l.value
          }, () => [
            L("span", {
              title: y.value.title,
              class: P(["grtvn-self-text", l.value.treeViewNodeSelfText])
            }, we(f.value), 11, Et)
          ]),
          y.value.addChildCallback ? (q(), M("button", {
            key: 5,
            id: h.value,
            type: "button",
            "aria-hidden": "true",
            tabindex: "-1",
            title: y.value.addChildTitle,
            class: P(["grtvn-self-action", [l.value.treeViewNodeSelfAction, l.value.treeViewNodeSelfAddChild]]),
            onClick: v[3] || (v[3] = (...D) => i(O) && i(O)(...D))
          }, [
            L("i", {
              class: P(["grtvn-self-add-child-icon", l.value.treeViewNodeSelfAddChildIcon])
            }, null, 2)
          ], 10, qt)) : Q("", !0),
          y.value.deletable ? (q(), M("button", {
            key: 6,
            id: C.value,
            type: "button",
            "aria-hidden": "true",
            tabindex: "-1",
            title: y.value.deleteTitle,
            class: P(["grtvn-self-action", [l.value.treeViewNodeSelfAction, l.value.treeViewNodeSelfDelete]]),
            onClick: $e
          }, [
            L("i", {
              class: P(["grtvn-self-delete-icon", l.value.treeViewNodeSelfDeleteIcon])
            }, null, 2)
          ], 10, $t)) : Q("", !0),
          L("div", {
            class: P(["grtvn-self-sibling-drop-target grtvn-self-next-target", [y.value._.isNextDropTarget ? "grtvn-self-sibling-drop-target-hover" : ""]])
          }, null, 2)
        ], 42, It),
        L("div", {
          class: P(["grtvn-children-wrapper", l.value.treeViewNodeChildrenWrapper])
        }, [
          y.value.state.expanded && !i(X) ? E(d.$slots, "loading", {
            key: 0,
            model: n.value,
            customClasses: l.value
          }, () => [
            L("span", {
              class: P(["grtvn-loading", l.value.treeViewNodeLoading])
            }, " ... ", 2)
          ]) : Q("", !0),
          i(he) ? De((q(), M("ul", {
            key: 1,
            class: P(["grtvn-children", l.value.treeViewNodeChildren]),
            role: "group",
            "aria-hidden": !y.value.state.expanded
          }, [
            (q(!0), M(Be, null, He(i(Y), (D) => {
              var pe, Oe;
              return q(), Je(H, {
                key: D[(Oe = (pe = D.treeNodeSpec) == null ? void 0 : pe.idProperty) != null ? Oe : "id"],
                depth: t.depth + 1,
                "initial-model": D,
                "model-defaults": t.modelDefaults,
                "parent-id": p.value,
                "selection-mode": t.selectionMode,
                "tree-id": $.value,
                "initial-radio-group-values": b.value,
                "aria-key-map": t.ariaKeyMap,
                "is-mounted": t.isMounted,
                onTreeNodeClick: v[10] || (v[10] = (w, R) => d.$emit(i(r).Click, w, R)),
                onTreeNodeDblclick: v[11] || (v[11] = (w, R) => d.$emit(i(r).DoubleClick, w, R)),
                onTreeNodeCheckboxChange: tt,
                onTreeNodeChildCheckboxChange: v[12] || (v[12] = (w, R, le) => d.$emit(i(r).ChildCheckboxChange, w, R, le)),
                onTreeNodeRadioChange: v[13] || (v[13] = (w, R) => d.$emit(i(r).RadioChange, w, R)),
                onTreeNodeExpandedChange: v[14] || (v[14] = (w) => d.$emit(i(r).ExpandedChange, w)),
                onTreeNodeChildrenLoad: v[15] || (v[15] = (w) => d.$emit(i(r).ChildrenLoad, w)),
                onTreeNodeSelectedChange: v[16] || (v[16] = (w) => d.$emit(i(r).SelectedChange, w)),
                onTreeNodeAdd: v[17] || (v[17] = (w, R) => d.$emit(i(r).Add, w, R)),
                onTreeNodeDelete: et,
                onTreeNodeAriaFocusableChange: v[18] || (v[18] = (w) => d.$emit(i(r).FocusableChange, w)),
                onTreeNodeAriaRequestParentFocus: v[19] || (v[19] = () => i(re)()),
                onTreeNodeAriaRequestFirstFocus: v[20] || (v[20] = (w) => d.$emit(i(r).RequestFirstFocus, w)),
                onTreeNodeAriaRequestLastFocus: v[21] || (v[21] = () => d.$emit(i(r).RequestLastFocus)),
                onTreeNodeAriaRequestPreviousFocus: i(ue),
                onTreeNodeAriaRequestNextFocus: i(se),
                onTreeNodeDragMove: i(F),
                onTreeNodeDrop: i(I)
              }, {
                checkbox: z(({ model: w, customClasses: R, inputId: le, checkboxChangeHandler: Te }) => [
                  E(d.$slots, "checkbox", {
                    model: w,
                    customClasses: R,
                    inputId: le,
                    checkboxChangeHandler: Te
                  })
                ]),
                radio: z(({ model: w, customClasses: R, inputId: le, radioGroupValues: Te, radioChangeHandler: lt }) => [
                  E(d.$slots, "radio", {
                    model: w,
                    customClasses: R,
                    inputId: le,
                    radioGroupValues: Te,
                    radioChangeHandler: lt
                  })
                ]),
                text: z(({ model: w, customClasses: R }) => [
                  E(d.$slots, "text", {
                    model: w,
                    customClasses: R
                  })
                ]),
                loading: z(({ model: w, customClasses: R }) => [
                  E(d.$slots, "loading", {
                    model: w,
                    customClasses: R
                  })
                ]),
                _: 2
              }, 1032, ["depth", "initial-model", "model-defaults", "parent-id", "selection-mode", "tree-id", "initial-radio-group-values", "aria-key-map", "is-mounted", "onTreeNodeAriaRequestPreviousFocus", "onTreeNodeAriaRequestNextFocus", "onTreeNodeDragMove", "onTreeNodeDrop"]);
            }), 128))
          ], 10, Ot)), [
            [st, y.value.state.expanded]
          ]) : Q("", !0)
        ], 2)
      ], 42, wt);
    };
  }
};
const jt = /* @__PURE__ */ L("span", { class: "grtv-loading" }, " ... ", -1), Kt = ["aria-multiselectable"], Bt = {
  __name: "TreeView",
  props: {
    customAriaKeyMap: {
      type: Object,
      required: !1,
      default: function() {
        return {};
      },
      validator: function(t) {
        for (const o in t)
          if (!Array.isArray(t[o]) || t[o].some((a) => !Number.isInteger(a)))
            return console.error(`customAriaKeyMap properties must be Arrays of numbers (corresponding to keyCodes); property '${o}' fails check.`), !1;
        return !0;
      }
    },
    filterMethod: {
      type: Function,
      required: !1,
      default: null
    },
    initialModel: {
      type: Array,
      required: !1,
      default: function() {
        return [];
      }
    },
    loadNodesAsync: {
      type: Function,
      required: !1,
      default: null
    },
    modelDefaults: {
      type: Object,
      required: !1,
      default: function() {
        return {};
      }
    },
    selectionMode: {
      type: String,
      required: !1,
      default: A.None,
      validator: function(t) {
        return Object.values(A).includes(t);
      }
    },
    skinClass: {
      type: String,
      required: !1,
      default: "grtv-default-skin",
      validator: function(t) {
        return t === null || !t.match(/\s/);
      }
    }
  },
  emits: [
    r.Add,
    r.CheckboxChange,
    r.ChildrenLoad,
    r.ChildCheckboxChange,
    r.Click,
    r.Delete,
    r.DoubleClick,
    r.ExpandedChange,
    r.RadioChange,
    r.RootNodesLoad,
    r.SelectedChange
  ],
  setup(t, { expose: o, emit: a }) {
    const n = t, b = ut({
      activateItem: [32],
      selectItem: [13],
      focusLastItem: [35],
      focusFirstItem: [36],
      collapseFocusedItem: [37],
      expandFocusedItem: [39],
      focusPreviousItem: [38],
      focusNextItem: [40],
      insertItem: [45],
      deleteItem: [46]
    }), s = j(!1), h = j(!1), e = j(n.initialModel), l = j({}), C = j(""), g = j(null), { generateUniqueId: p } = Ge(), { depthFirstTraverse: c } = Pe(e), {
      focusableNodeModel: N,
      handleFocusableChange: S
    } = pt(), {
      focus: f,
      focusFirst: u,
      focusLast: m,
      focusNext: y,
      focusPrevious: $,
      isFocused: V,
      unfocus: O
    } = B(), {
      ariaMultiselectable: X,
      enforceSelectionMode: ie,
      handleNodeSelectedChange: Y
    } = gt(e, Z(n, "selectionMode"), N, a), {
      isSelectable: Ne,
      isSelected: he,
      select: G
    } = ge(Z(n, "selectionMode")), {
      findById: Ce,
      getCheckedCheckboxes: ye,
      getCheckedRadioButtons: be,
      getMatching: Se,
      getSelected: re,
      removeById: se
    } = yt(e, l, Z(n, "selectionMode")), { dragMoveNode: ue, drop: me } = Ct(e, C, Ce, se);
    vt(e);
    const _ = T(() => typeof n.loadNodesAsync != "function" || s.value), xe = T(() => Object.assign({}, b, n.customAriaKeyMap));
    dt(async () => {
      if (await ke(), g.value.id && (C.value = g.value.id), e.value.length > 0) {
        let k = null;
        c((x) => {
          V(x) && (N.value ? O(x) : N.value = x), n.selectionMode !== A.None && k === null && he(x) && (k = x);
        }), N.value || (N.value = k || e.value[0], f(N)), k === null && Ne(N) && n.selectionMode === A.SelectionFollowsFocus && G(N), ie();
      }
      ct(() => {
        n.selectionMode === A.Single && ie(), h.value = !0;
      });
    });
    async function ke() {
      if (!_.value) {
        var k = await n.loadNodesAsync();
        k && (s.value = !0, e.value.splice(0, e.value.length, ...k), a(r.RootNodesLoad, e.value));
      }
    }
    function de(k) {
      let x = e.value.indexOf(k);
      x > -1 && (Fe(k), e.value.splice(x, 1)), a(r.Delete, k);
    }
    function Fe(k) {
      V(k) && (e.value.indexOf(k) === 0 ? e.value.length > 0 && y(e.value, k) : $(e.value, k));
    }
    return ft("filterMethod", Z(n, "filterMethod")), C.value = p(), o({
      getCheckedCheckboxes: ye,
      getCheckedRadioButtons: be,
      getMatching: Se,
      getSelected: re
    }), (k, x) => (q(), M("div", {
      ref_key: "treeElement",
      ref: g,
      class: P(["grtv-wrapper", t.skinClass])
    }, [
      _.value ? Q("", !0) : E(k.$slots, "loading-root", { key: 0 }, () => [
        jt
      ]),
      _.value ? (q(), M("ul", {
        key: 1,
        class: "grtv",
        role: "tree",
        "aria-multiselectable": i(X)
      }, [
        (q(!0), M(Be, null, He(e.value, (ee) => {
          var ce, te;
          return q(), Je(Mt, {
            key: ee[(te = (ce = ee.treeNodeSpec) == null ? void 0 : ce.idProperty) != null ? te : "id"],
            "aria-key-map": xe.value,
            depth: 0,
            "model-defaults": t.modelDefaults,
            "initial-model": ee,
            "selection-mode": t.selectionMode,
            "tree-id": C.value,
            "is-mounted": h.value,
            "initial-radio-group-values": l.value,
            onTreeNodeClick: x[0] || (x[0] = (F, I) => k.$emit(i(r).Click, F, I)),
            onTreeNodeDblclick: x[1] || (x[1] = (F, I) => k.$emit(i(r).DoubleClick, F, I)),
            onTreeNodeCheckboxChange: x[2] || (x[2] = (F, I) => k.$emit(i(r).CheckboxChange, F, I)),
            onTreeNodeChildCheckboxChange: x[3] || (x[3] = (F, I, K) => k.$emit(i(r).ChildCheckboxChange, F, I, K)),
            onTreeNodeRadioChange: x[4] || (x[4] = (F, I) => k.$emit(i(r).RadioChange, F, I)),
            onTreeNodeExpandedChange: x[5] || (x[5] = (F) => k.$emit(i(r).ExpandedChange, F)),
            onTreeNodeChildrenLoad: x[6] || (x[6] = (F) => k.$emit(i(r).ChildrenLoad, F)),
            onTreeNodeSelectedChange: i(Y),
            onTreeNodeAdd: x[7] || (x[7] = (F, I) => k.$emit(i(r).Add, F, I)),
            onTreeNodeDelete: de,
            onTreeNodeAriaFocusableChange: i(S),
            onTreeNodeAriaRequestFirstFocus: x[8] || (x[8] = (F) => i(u)(e.value, F)),
            onTreeNodeAriaRequestLastFocus: x[9] || (x[9] = (F) => i(m)(e.value)),
            onTreeNodeAriaRequestPreviousFocus: x[10] || (x[10] = (F) => i($)(e.value, F)),
            onTreeNodeAriaRequestNextFocus: x[11] || (x[11] = (F, I) => i(y)(e.value, F, I)),
            onTreeNodeDragMove: i(ue),
            onTreeNodeDrop: i(me)
          }, {
            checkbox: z(({ model: F, customClasses: I, inputId: K, checkboxChangeHandler: U }) => [
              E(k.$slots, "checkbox", {
                model: F,
                customClasses: I,
                inputId: K,
                checkboxChangeHandler: U
              })
            ]),
            radio: z(({ model: F, customClasses: I, inputId: K, radioGroupValues: U, radioChangeHandler: fe }) => [
              E(k.$slots, "radio", {
                model: F,
                customClasses: I,
                inputId: K,
                radioGroupValues: U,
                radioChangeHandler: fe
              })
            ]),
            text: z(({ model: F, customClasses: I }) => [
              E(k.$slots, "text", {
                model: F,
                customClasses: I
              })
            ]),
            loading: z(({ model: F, customClasses: I }) => [
              E(k.$slots, "loading", {
                model: F,
                customClasses: I
              })
            ]),
            _: 2
          }, 1032, ["aria-key-map", "model-defaults", "initial-model", "selection-mode", "tree-id", "is-mounted", "initial-radio-group-values", "onTreeNodeSelectedChange", "onTreeNodeAriaFocusableChange", "onTreeNodeDragMove", "onTreeNodeDrop"]);
        }), 128))
      ], 8, Kt)) : Q("", !0)
    ], 2));
  }
};
export {
  Bt as TreeView
};
